diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index 6509bf8911d2..fc3100759d88 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -834,6 +834,17 @@
 #define USB_DEVICE_ID_MS_TOUCH_COVER_2   0x07a7
 #define USB_DEVICE_ID_MS_TYPE_COVER_2    0x07a9
 #define USB_DEVICE_ID_MS_POWER_COVER     0x07da
+#define USB_DEVICE_ID_MS_TYPE_COVER_3    0x07de
+#define USB_DEVICE_ID_MS_TYPE_COVER_PRO_3  0x07dc
+#define USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_1  0x07de
+#define USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_2  0x07e2
+#define USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_JP 0x07dd
+#define USB_DEVICE_ID_MS_TYPE_COVER_PRO_4  0x07e8
+#define USB_DEVICE_ID_MS_TYPE_COVER_PRO_4_1  0x07e4
+#define USB_DEVICE_ID_MS_SURFACE_BOOK    0x07cd
+#define USB_DEVICE_ID_MS_SURFACE_BOOK_2    0x0922
+#define USB_DEVICE_ID_MS_SURFACE_GO      0x096f
+#define USB_DEVICE_ID_MS_SURFACE_VHF   0xf001
 #define USB_DEVICE_ID_MS_XBOX_ONE_S_CONTROLLER	0x02fd
 #define USB_DEVICE_ID_MS_PIXART_MOUSE    0x00cb
 
@@ -1268,6 +1279,9 @@
 #define USB_VENDOR_ID_UGTIZER			0x2179
 #define USB_DEVICE_ID_UGTIZER_TABLET_GP0610	0x0053
 
+#define USB_VENDOR_ID_1018  0x1018
+#define USB_DEVICE_ID_1018_MUTITOUCH 0x1006
+
 #define USB_VENDOR_ID_VIEWSONIC			0x0543
 #define USB_DEVICE_ID_VIEWSONIC_PD1011		0xe621
 
diff --git a/drivers/hid/hid-microsoft.c b/drivers/hid/hid-microsoft.c
index 2d8b589201a4..df94ba8dab89 100644
--- a/drivers/hid/hid-microsoft.c
+++ b/drivers/hid/hid-microsoft.c
@@ -443,7 +443,9 @@ static const struct hid_device_id ms_devices[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_POWER_COVER),
 		.driver_data = MS_HIDINPUT },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_COMFORT_KEYBOARD),
-		.driver_data = MS_ERGONOMY},
+		.driver_data = MS_ERGONOMY },
+  { HID_USB_DEVICE(USB_VENDOR_ID_1018, USB_DEVICE_ID_1018_MUTITOUCH),
+    .driver_data = MS_HIDINPUT },
 
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_BT),
 		.driver_data = MS_PRESENTER },
diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c
index 3cfeb1629f79..7f157bef2406 100644
--- a/drivers/hid/hid-multitouch.c
+++ b/drivers/hid/hid-multitouch.c
@@ -133,6 +133,9 @@ struct mt_application {
 	int prev_scantime;		/* scantime reported previously */
 
 	bool have_contact_count;
+  bool pressure_emulate;
+  __s32 fake_pressure;
+  int pressure_step;
 };
 
 struct mt_class {
@@ -767,6 +770,15 @@ static int mt_touch_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 						     MT_TOOL_PALM, 0, 0);
 
 			MT_STORE_FIELD(confidence_state);
+      if (app->application == HID_DG_TOUCHPAD &&
+					 (cls->name == MT_CLS_DEFAULT || cls->name == MT_CLS_WIN_8) &&
+					 !test_bit(ABS_MT_PRESSURE, hi->input->absbit)){
+         app->pressure_emulate = true;
+         app->fake_pressure = 0;
+         input_set_abs_params(hi->input, ABS_MT_PRESSURE, 0, 255, 0, 0);
+         mt_store_field(hdev, app, &app->fake_pressure, offsetof(struct mt_usages, p));
+         hid_dbg(hdev, "Set device pressure_emulate enable");
+      }
 			return 1;
 		case HID_DG_TIPSWITCH:
 			if (field->application != HID_GD_SYSTEM_MULTIAXIS)
@@ -1074,6 +1086,17 @@ static int mt_process_slot(struct mt_device *td, struct input_dev *input,
 			minor = minor >> 1;
 		}
 
+    hid_dbg(td->hdev, "emulate:%x,x:%d, pressure:%d",
+      app->pressure_emulate, *slot->x, *slot->p);
+    if (app->pressure_emulate && slot->x) {
+      if (app->fake_pressure > 130)
+        app->pressure_step = -10;
+      else if (app->fake_pressure < 60)
+        app->pressure_step = 30;
+      else if (app->fake_pressure > 80)
+        app->pressure_step = 5;
+		  app->fake_pressure += app->pressure_step;
+	  }
 		input_event(input, EV_ABS, ABS_MT_POSITION_X, *slot->x);
 		input_event(input, EV_ABS, ABS_MT_POSITION_Y, *slot->y);
 		input_event(input, EV_ABS, ABS_MT_TOOL_X, *slot->cx);
@@ -1302,9 +1325,11 @@ static int mt_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 	    field->application != HID_DG_TOUCHSCREEN &&
 	    field->application != HID_DG_PEN &&
 	    field->application != HID_DG_TOUCHPAD &&
+       field->application != HID_GD_MOUSE &&
 	    field->application != HID_GD_KEYBOARD &&
 	    field->application != HID_GD_SYSTEM_CONTROL &&
 	    field->application != HID_CP_CONSUMER_CONTROL &&
+      field->application != HID_DG_TOUCHSCREEN &&
 	    field->application != HID_GD_WIRELESS_RADIO_CTLS &&
 	    field->application != HID_GD_SYSTEM_MULTIAXIS &&
 	    !(field->application == HID_VD_ASUS_CUSTOM_MEDIA_KEYS &&
@@ -1356,6 +1381,13 @@ static int mt_input_mapped(struct hid_device *hdev, struct hid_input *hi,
 	struct mt_device *td = hid_get_drvdata(hdev);
 	struct mt_report_data *rdata;
 
+	if (field->application == HID_DG_TOUCHSCREEN ||
+			field->application == HID_DG_TOUCHPAD) {
+		if (usage->type == EV_KEY || usage->type == EV_ABS)
+			set_bit(usage->type, hi->input->evbit);
+		return -1;
+	}
+
 	rdata = mt_find_report_data(td, field->report);
 	if (rdata && rdata->is_mt_collection) {
 		/* We own these mappings, tell hid-input to ignore them */
@@ -1573,6 +1605,7 @@ static int mt_input_configured(struct hid_device *hdev, struct hid_input *hi)
 	case HID_DG_STYLUS:
 		/* force BTN_STYLUS to allow tablet matching in udev */
 		__set_bit(BTN_STYLUS, hi->input->keybit);
+    __set_bit(INPUT_PROP_DIRECT, hi->input->propbit)
 		break;
 	case HID_VD_ASUS_CUSTOM_MEDIA_KEYS:
 		suffix = "Custom Media Keys";
@@ -1986,6 +2019,63 @@ static const struct hid_device_id mt_devices[] = {
 		HID_USB_DEVICE(USB_VENDOR_ID_LG,
 			USB_DEVICE_ID_LG_MELFAS_MT) },
 
+ /* Microsoft Touch Cover */
+ { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+           USB_DEVICE_ID_MS_TOUCH_COVER_2) },
+
+   /* Microsoft Type Cover */
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+                   USB_DEVICE_ID_MS_TYPE_COVER_2) },
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+                   USB_DEVICE_ID_MS_TYPE_COVER_3) },
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+                   USB_DEVICE_ID_MS_TYPE_COVER_PRO_3) },
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+                   USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_1) },
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+                   USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_2) },
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+                   USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_JP) },
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+                   USB_DEVICE_ID_MS_TYPE_COVER_PRO_4) },
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+                   USB_DEVICE_ID_MS_TYPE_COVER_PRO_4_1) },
+
+   /* Microsoft Surface Book */
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+           USB_DEVICE_ID_MS_SURFACE_BOOK) },
+
+   /* Microsoft Surface Book 2 */
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+           USB_DEVICE_ID_MS_SURFACE_BOOK_2) },
+
+   /* Microsoft Surface Go */
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+           USB_DEVICE_ID_MS_SURFACE_GO) },
+
+   /* Microsoft Surface Laptop */
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,
+                   USB_VENDOR_ID_MICROSOFT,
+                   USB_DEVICE_ID_MS_SURFACE_VHF) },
+
+   /* Microsoft Power Cover */
+   { .driver_data = MT_CLS_EXPORT_ALL_INPUTS,
+           MT_USB_DEVICE(USB_VENDOR_ID_MICROSOFT,
+           USB_DEVICE_ID_MS_POWER_COVER) },
+
 	/* MosArt panels */
 	{ .driver_data = MT_CLS_CONFIDENCE_MINUS_ONE,
 		MT_USB_DEVICE(USB_VENDOR_ID_ASUS,
